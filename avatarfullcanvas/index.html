<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>Full-Screen Perlin Noise Background</title>
<style>
    html, body {margin:0; padding:0; overflow:hidden; height:100%; width:100%; background:#000;}
    canvas {display:block;}
</style>
</head>
<body>
<canvas id="fluid"></canvas>

<script>
// Simplex Noise Implementation
class SimplexNoise {
    constructor(seed = 0) {
        this.p = [];
        for (let i = 0; i < 256; i++) this.p[i] = Math.floor(Math.random() * 256);
        this.perm = [...this.p, ...this.p];
    }
    
    fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
    lerp(t, a, b) { return a + t * (b - a); }
    grad(hash, x, y, z) {
        const h = hash & 15;
        const u = h < 8 ? x : y;
        const v = h < 8 ? y : z;
        return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
    }
    
    perlin3(x, y, z) {
        const xi = Math.floor(x) & 255;
        const yi = Math.floor(y) & 255;
        const zi = Math.floor(z) & 255;
        
        const xf = x - Math.floor(x);
        const yf = y - Math.floor(y);
        const zf = z - Math.floor(z);
        
        const u = this.fade(xf);
        const v = this.fade(yf);
        const w = this.fade(zf);
        
        const p = this.perm;
        const aa = p[p[p[xi] + yi] + zi];
        const ab = p[p[p[xi] + yi + 1] + zi];
        const ba = p[p[p[xi + 1] + yi] + zi];
        const bb = p[p[p[xi + 1] + yi + 1] + zi];
        const aaa = p[aa + zi];
        const aab = p[aa + zi + 1];
        const aba = p[ab + zi];
        const abb = p[ab + zi + 1];
        const baa = p[ba + zi];
        const bab = p[ba + zi + 1];
        const bba = p[bb + zi];
        const bbb = p[bb + zi + 1];
        
        const g0 = this.grad(aaa, xf, yf, zf);
        const g1 = this.grad(aab, xf, yf, zf - 1);
        const g2 = this.grad(aba, xf, yf - 1, zf);
        const g3 = this.grad(abb, xf, yf - 1, zf - 1);
        const g4 = this.grad(baa, xf - 1, yf, zf);
        const g5 = this.grad(bab, xf - 1, yf, zf - 1);
        const g6 = this.grad(bba, xf - 1, yf - 1, zf);
        const g7 = this.grad(bbb, xf - 1, yf - 1, zf - 1);
        
        const l0 = this.lerp(w, g0, g1);
        const l1 = this.lerp(w, g2, g3);
        const l2 = this.lerp(w, g4, g5);
        const l3 = this.lerp(w, g6, g7);
        const l4 = this.lerp(v, l0, l1);
        const l5 = this.lerp(v, l2, l3);
        return this.lerp(u, l4, l5);
    }
}

const canvas = document.getElementById("fluid");
const ctx = canvas.getContext("2d");
const noise = new SimplexNoise(42);

let width = canvas.width = window.innerWidth;
let height = canvas.height = window.innerHeight;

const step = 4;
const color1 = {r:255, g:0, b:255}; // Magenta
const color2 = {r:0, g:255, b:255}; // Cyan

let z = 0;

function draw(){
    for(let y=0; y<height; y+=step){
        for(let x=0; x<width; x+=step){
            const n1 = noise.perlin3((x+z*20)*0.002, (y+z*15)*0.002, z);
            const n2 = noise.perlin3((y-z*10)*0.0025, (x+z*25)*0.0025, z+1000);
            const n = (n1 + n2)/2 * 0.5 + 0.5;

            const r = Math.round(color1.r*(1-n) + color2.r*n);
            const g = Math.round(color1.g*(1-n) + color2.g*n);
            const b = Math.round(color1.b*(1-n) + color2.b*n);

            ctx.fillStyle = `rgb(${r},${g},${b})`;
            ctx.fillRect(x,y,step,step);
        }
    }
    z += 0.02; // Geschwindigkeit erhÃ¶ht von 0.005
    requestAnimationFrame(draw);
}

draw();

window.addEventListener('resize', ()=>{
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
});
</script>
</body>
</html>
